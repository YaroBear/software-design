Please keep all files related to a homework or an assignment within the appropriate directory. Files checked in outside of specific homework or assignment directory will not be reviewed or graded for that homework/assignment.

Check in and modify files as many times as you like. You will not be able to modify the files after the deadline.

During pairing rotate who checks in the code. There should be somewhat (approximately) the same number of checkins from each member of a pair/team. In other words, we don't want to see check in from only one person of the pair/team.

You will work as a pair, both of you are responsible for the completed work in all assignments and homework. Reasonable effort is expected from each person.

The deadlines are strict, there will be no extensions. Don't email any code to Venkat or to the mailing list. Your last check in before the deadline will be graded. If your last check in breaks the code, both you and your pair will lose significant points.

Please feel free to ask for frequent reviews. See the reviews/readme.txt file for details on how to ask for reviews.

You can evolve the answers and solutions based on the reviews. Only the latest checkin at the time of review will be looked at. Also the final check in will be the only one graded.

Please read the academic honesty policy posted on the course mailing list.

Now to homework #1.

------------------------------------------------------------------------------
HW1: Due 11:59PM September 1

Q1. What's simple design?

From a user perspective, simple design is easy to understand, easy to use, and easy to maintain.  This can be difficult to accomplish because typically the intended users of a piece of software are not the developers of that software.  This makes communcation between the developer and customer supremely important.  The developer must be able to produce an appropriate model of the domain that does not capture details irrelevant to the customer.  As development continues, allowing the customer to interact with the software is important to help mitigate the "observer effect" and provide feedback about the development direction.  This ensures that only features relevant to the customers needs (or relevant user stories) are captured.

From a software development perspective, simple design is minimalistic design.  Meaning, every feature is relevant to a user story.  However, even with minimalistic design, problems can occur as requirements change.  Care must be taken to ensure that new features are relevant and work well with the existing design.  A good strategy to accomplish this involves sorting new user stories into two lists:  one ordered by the value of the new feature to the customer, and the other ordered by the impact to the current architecture.  The features with the highest value and least impact would be selected.  Considering the impact of each new feature minimizes the likelihood of adding a feature that would "disrupt the current system".  This selection process for new features and the general lack of irrelevant features of a minimalistic design ensures the software fails less or at least fails "more gracefully".  The software "fails less" because having fewer irrelevant features means there are fewer features that can fail, or it fails "more gracefully" because the integrity of the system was considered before any new feature was added.

Q2. Why should design be simple?

When designing software we must take many things into consideration. This includes the problem we are trying to solve, the domain, complexity, and application. We are handed a set of requirements that must be met to the best of our ability, but we cannot always account for all of the variables for a peice of software. All of the requirements must come together gracefully, which is especially difficult as the project grows and as more factors come into play, which is why designing software is such a challenge.

When software grows, a strong yet simple foundation is the determining factor for much of the success of the software. From a user perspective, you do not want to be paying the software team to constantly tear down and rebuild the base layer due to poor planning. Similarly, a software engineer's time should be dedicated to building new and worthwhile features instead of getting stuck in an endless development loop. Having a simple design makes the project easier to extend through abstraction. If you have to modify the base layer of the code whenever you are working on a new feature, the software becomes increasingly more expensive and difficult to maintain. New features should be attainable without affecting other systems through inheritance and other design principles.

The readability of the code is another important factor that determines cost for both the user and developer. Although the interface for the software should be well documented, classes and methods should be easy to spot and self-describing if any changes need to be made down the line. The less time spent looking for code results in more time and money saved. Similarly, bugs are much easier to track in concise methods rather than in bloated methods that implement more than one function. Every class should maintain a library of related methods where each method serves one particular function.

A simple design allows the developer to follow the original requirements in manageable sprints, and enables them to be more responsive to unanticipated changes when the requirements change. If you are designing software for another end user, refactoring code and making small changes to specific functions is much easier and cost effective than rewriting entire features just because the end user was unsatisfied with a small detail. When software is easy to maintain, more maintainence is likely to be done as well. If features are too complex then developers are less likely to fix them or would end up having to start over entirely.


Guidelines

Q3. In your experience, from what you've seen, has there been problems with design not being simple or benefits from it being simple? Give examples of situations and impact. Discuss.

Nick:

Yaro and I were in the same database course last spring.  The class had a big group project with several requirements.  Our teams project was to create a database system with a front end for an organ donation network.  The requirements were that we have at least 2 triggers (2 actions automatically triggered when entering new data into the system), at least 2 different user views, a well defined database schema, and reports based on the data.  

The requirements seemed a little disconnected from the main topic of "organ donation", but we kept them in mind from the beginning.  We planned our two user views based on our research on the organ donor network.  We planned our triggers to be part of our matching functions.  We did not have a clear idea of what the triggers would do at that point, but I think keeping them in mind the whole way made implementing them easier at the end.  We though about issues involved with generating reports about medical information early on (like patient anonymity).  We made choices in how we modelled the data to make it simpler.  An example is that we expressed patient HLA type as a string so it was easier to work with.  This would not be appropriate in a real world context, but shows that our design was different given a different context. 

By the time the project was due, there were still plenty of changes to make and bugs to chase down but all of the assignment requirements had been met.  Looking back its clear how easy it is to get sidetracked with irrelevant features or changes.  We had a couple of discussions about the direction of new features and whether or not they were going to get us closer to meeting our goal.  I think we did alright because made a point of keeping things simple and because we focused on the requirements early.

Yaro:

Planning the schema as well as some of the basic API end-points early on helped to get the project rolling. As the project was coming together and some of the main features were implemented, we noticed there was a lot of revision happening to the existing code. We had to do a lot of thinking on the spot, and we tried a number of different strategies before arriving to something that just worked. Our code was not very modular, and could have benefitted from having a simpler design of feature classes, where each module would contain related methods that implement small and managable single task functions. For example, our routes file which provides much of the API functionality was extremely cluttered (1400+ lines of code) and had clashing styles of programming. We did not maintain any particular design principle in mind, and I think a lot of time of rewriting and planning could have been saved had we stuck to a particular design pattern.