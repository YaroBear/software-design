Please keep all files related to a homework or an assignment within the appropriate directory. Files checked in outside of specific homework or assignment directory will not be reviewed or graded for that homework/assignment.

Check in and modify files as many times as you like. You will not be able to modify the files after the deadline.

During pairing rotate who checks in the code. There should be somewhat (approximately) the same number of checkins from each member of a pair/team. In other words, we don't want to see check in from only one person of the pair/team.

You will work as a pair, both of you are responsible for the completed work in all assignments and homework. Reasonable effort is expected from each person.

The deadlines are strict, there will be no extensions. Don't email any code to Venkat or to the mailing list. Your last check in before the deadline will be graded. If your last check in breaks the code, both you and your pair will lose significant points.

Please feel free to ask for frequent reviews. See the reviews/readme.txt file for details on how to ask for reviews.

You can evolve the answers and solutions based on the reviews. Only the latest checkin at the time of review will be looked at. Also the final check in will be the only one graded.

Please read the academic honesty policy posted on the course mailing list.

Now to homework #1.

------------------------------------------------------------------------------
HW1: Due 11:59PM September 1

Q1. What's simple design?

From a user perspective, simple design is easy to understand, easy to use, and easy to maintain.  This can be difficult to accomplish because typically the intended users of a piece of software are not the developers of that software.  This makes communcation between the developer and customer supremely important.  The developer must be able to produce an appropriate model of the domain that does not capture details irrelevant to the customer.  As development continues, allowing the customer to interact with the software is important to help mitigate the "observer effect" and provide feedback about the development direction.  This ensures that only features relevant to the customers needs (or relevant user stories) are captured.

From a software development perspective, simple design is minimalistic design.  Meaning, every feature is relevant to a user story.  However, even with minimalistic design, problems can occur as requirements change.  Care must be taken to ensure that new features are relevant and work well with the existing design.  A good strategy to accomplish this involves sorting new user stories into two lists:  one ordered by the value of the new feature to the customer, and the other ordered by the impact to the current architecture.  The features with the highest value and least impact would be selected.  Considering the impact of each new feature minimizes the likelihood of adding a feature that would "disrupt the current system".  This selection process for new features and the general lack of irrelevant features of a minimalistic design ensures the software fails less or at least fails "more gracefully".  The software "fails less" because having fewer irrelevant features means there are fewer features that can fail, or it fails "more gracefully" because the integrity of the system was considered before any new feature was added.

Q2. Why should design be simple?

Simple design makes code easier to understand, easier to maintain, easier to change, and less likely to fail.

Q3. In your experience, from what you've seen, has there been problems with design not being simple or benefits from it being simple? Give examples of situations and impact. Discuss.

Nick:

Yaro and I were in the same database course last spring.  The class had a big group project with several requirements.  Our teams project was to create a database system with a front end for an organ donation network.  The requirements were that we have at least 2 triggers (2 actions automatically triggered when entering new data into the system), at least 2 different user views, a well defined database schema, and reports based on the data.  

The requirements seemed a little disconnected from the main topic of "organ donation", but we kept them in mind from the beginning.  We planned our two user views based on our research on the organ donor network.  We planned our triggers to be part of our matching functions.  We did not have a clear idea of what the triggers would do at that point, but I think keeping them in mind the whole way made implementing them easier at the end.  We though about issues involved with generating reports about medical information early on (like patient anonymity).  We made choices in how we modelled the data to make it simpler.  An example is that we expressed patient HLA type as a string so it was easier to work with.  This would not be appropriate in a real world context, but shows that our design was different given a different context. 

By the time the project was due, there were still plenty of changes to make and bugs to chase down but all of the assignment requirements had been met.  Looking back its clear how easy it is to get sidetracked with irrelevant features or changes.  We had a couple of discussions about the direction of new features and whether or not they were going to get us closer to meeting our goal.  I think we did alright because made a point of keeping things simple and because we focused on the requirements early.

Yaro:

Planning the schema as well as some of the basic API end-points early on helped to get the project rolling. As the project was coming together and some of the main features were implemented, we noticed there was a lot of revision happening to the existing code. We had to do a lot of thinking on the spot, and we tried a number of different strategies before arriving to something that just worked. Although our code was functional and we had an excellent presentation, looking back at the code there are a lot of things I would have liked to change in terms of design. For example, our routes file which provides much of the API functionality is extremely cluttered (1400+ lines of code) and has clashing styles of programming. This is mainly due to having to learn the entire MEAN stack on the spot while still having to meet deadlines. I think more strategic design would have helped immensely, but we were sort of oblivious to how much work this project actually needed. The beginning was mostly smooth sailing, but we quickly ran into rough waters once our strategic design was exhausted and things that could have been made simple were made complicated.