HW2: Due 11:59PM September 15

In this homework we'll create an initial strategic design for a version of the minesweeper game.

Let's first describe the version of the game that we'll design. We'll not be writing any code in this homework, but only creating an initial design.

The object of the game is for a player to find and seal all ten mines hidden  among hundred cells (10 x 10 cells). The mines may be in any random location.

There are three types of cells: mined cell, adjacent cell, and empty cell. 

A mined cell has a hidden mine.

An adjacent cell is next to one or more mined cells and knows the number of mines next to it. This number is not revealed to the player initially. 

An empty cell has no mine and is not next to a mined cell.

At the start of the game all cells are displayed grayed out, the player has no initial clue which cells are mined, adjacent, or empty. The player may either expose a cell or seal it.

The player may seal a cell if they suspect that cell to have a mine. Only an unexposed cell can be sealed. A sealed cell is shown with a seal symbol. A player may unseal a sealed cell and it will be displayed gray again.

Only an unexposed and unsealed cell can be exposed. 

The behavior of a cell when exposed depends on the type of the cell.

Exposing a mined cell ends the game.

If an empty cell is exposed, the player can see that it's empty. Furthermore, when an empty cell is exposed, it will trigger an expose action on all its unsealed neighbors.

When an adjacent cell is exposed (either due to users direct action or due 
to the successive action from exposing of a neighboring cell) it's count 
is shown and no further action happens.

There are two outcomes of the game. The player wins after sealing all the 
mines and exposing all the other cells. The player loses if a mined cell 
is exposed.

Create an initial design of this program and answer the questions below. 
Feel free to ask for frequent reviews.

Include a separate file (may be a scan of hand drawn picture if you like, or a pdf, tiff, word document, etc.) which shows a UML diagram of your design. Refer to that diagram from the text description you write here.

1. How would you design this program? 

Our game state and basic data structures for our "grid" are kept in separate extensible classes. Game, Cell, and Grid.  
The Cell class has attributes:  bool mined, bool sealed, bool exposed, and int adjacentMines.  The boolean attributes will be used to indicate if a cell has a mine (mined = true), if a cell has been sealed (sealed = true), and if a cell has been exposed (exposed = true).  The adjacentMines attribute is used to track the number of mines that are adjacent to the Cell instance.

For our basic data structures, we decided it would be easiest to keep track of our cells using a one-dimensional JavaScript array. This poses two advantages: 1. we can scale the game to any size using JavaScript built in dynamic arrays 2. Using a one-dimensional representation of the grid simplifies the math (and lines of code). For example:

Calculating adjacent cells for a grid that has width*height number of cells:

Top: currentCell – height
Bottom: currentCell + height
Left: currentCell – 1
Right: currentCell + 1
Top Left Corner: currentCell – height – 1
Top Right Corner: currentCell – height + 1
Bottom Left Corner: currentCell + height – 1
Bottom Right Corner: currentCell + height + 1

Bounds checking, in the example case where currentCell – 1 would be considered off the left edge of the “grid”, we use % math and array bounds checking.

Game layer:

Calls the Grid class to instantiate a new Grid array populated with instances of the Cell class - Grid(width, height, numberMines)

The only logic bound to the Game layer is
- Where each Cell is placed
- The size of each Cell in terms of display size
- Whether a cursor falls within the boundaries of a cell and the type of click (left or right click)
- A timer
- The mapping of Cell attributes to Cell textures. 

There is a texture for each attribute: mined, sealed, exposed, adjacentMines (number). 
The game layer is only concerned about where the player clicks and displaying the appropriate tile, and then calling winGame(), loseGame(), or continuation of a valid game state.

A valid game state is where a bomb has not been clicked, and there are tiles that are yet to be exposed. An end game state is where all tiles have been revealed and only cells that are mined have been sealed. Game.reset() can be called during a valid game state or end game state where a new instance of Grid is created, and then mapped to the game layer cells. Game.reset() resets the timer, and the timer starts when the first click event is detected.

The game's physical size on the screen is determined by the display.innerWidth and display.innerHeight of the browsers DOM to dynamically fit on any screen size. Each Cell size is a function of the game size and the number of cells in the game (default 10*10). Each Cell is drawn to the Canvas using CanvasRenderingContext2D.rect(xPos, yPos, width, height). The GUI will display the timer, as well as a reset button to call Game.reset().

Grid layer:

Grid(width, height, numberMines) is called by the Game layer. Grid randomly places the mines, and Grid.findAdjacentCells() increments Cell.numberMines of all adjacent Cell instances. Once all mines have been placed and Cell.adjacentMines calculated, the Grid array is returned to be used by the Game layer. The game layer interfaces with Cell methods Cell.expose(), Cell.seal(), Cell.unseal() to change Grid state, which is visually mapped in the game layer.

Cell layer:

Bool mined, bool sealed, bool exposed, and int adjacentMines define the state for every instance of Cell. The Grid layer creates as many Cell instances as necessary to fill the Grid array.

2. Discuss what language you would use.

We were originally considering Java, but after doing research on some GUI and even game engine platforms, we decided on using JavaScript. Modern applications are mostly web oriented these days, and now that flash and java applets are being deprecated for the web, it would make sense to build something modern. We both have experience using JavaScript in both the front and back end, and pairing this with the simple yet powerful Html5 Canvas we believe would make a great application.

3. How do you plan to structure the program, what libraries would you use?

The Game class will import the Html5 Canvas and our Cell and Grid classes. The sole purpose of the Game class will be to configure the GUI, add event listeners to the cells, enable the visuals of the game state (things such as time, reset, clicked on a bomb, sealed a cell, or win), while Grid keeps track of every instance of Cell and their statuses.