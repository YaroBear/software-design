HW2: Due 11:59PM September 15

In this homework we'll create an initial strategic design for a version of the minesweeper game.

Let's first describe the version of the game that we'll design. We'll not be writing any code in this homework, but only creating an initial design.

The object of the game is for a player to find and seal all ten mines hidden  among hundred cells (10 x 10 cells). The mines may be in any random location.

There are three types of cells: mined cell, adjacent cell, and empty cell. 

A mined cell has a hidden mine.

An adjacent cell is next to one or more mined cells and knows the number of mines next to it. This number is not revealed to the player initially. 

An empty cell has no mine and is not next to a mined cell.

At the start of the game all cells are displayed grayed out, the player has no initial clue which cells are mined, adjacent, or empty. The player may either expose a cell or seal it.

The player may seal a cell if they suspect that cell to have a mine. Only an unexposed cell can be sealed. A sealed cell is shown with a seal symbol. A player may unseal a sealed cell and it will be displayed gray again.

Only an unexposed and unsealed cell can be exposed. 

The behavior of a cell when exposed depends on the type of the cell.

Exposing a mined cell ends the game.

If an empty cell is exposed, the player can see that it's empty. Furthermore, when an empty cell is exposed, it will trigger an expose action on all its unsealed neighbors.

When an adjacent cell is exposed (either due to users direct action or due 
to the successive action from exposing of a neighboring cell) it's count 
is shown and no further action happens.

There are two outcomes of the game. The player wins after sealing all the 
mines and exposing all the other cells. The player loses if a mined cell 
is exposed.

Create an initial design of this program and answer the questions below. 
Feel free to ask for frequent reviews.

Include a separate file (may be a scan of hand drawn picture if you like, or a pdf, tiff, word document, etc.) which shows a UML diagram of your design. Refer to that diagram from the text description you write here.

1. How would you design this program? 

Our game state and basic data structures for our "grid" are kept in separate extensible classes. Game, Cell, and Grid.  
The Cell class has attributes:  bool mined, bool sealed, bool exposed, and int adjacentMines.  The boolean attributes will be used to indicate if a cell has a mine (mined = true), if a cell has been sealed (sealed = true), and if a cell has been exposed (exposed = true).  The adjacentMines attribute is used to track the number of mines that are adjacent to the Cell instance.

For our basic data structures, we decided it would be easiest to keep track of our cells using a one-dimensional JavaScript array. This poses two advantages: 1. we can scale the game to any size using JavaScript built in dynamic arrays 2. Using a one-dimensional representation of the grid simplifies the math (and lines of code). For example:

Calculating adjacent cells for a grid that has width*height number of cells:

Top: currentCell – height
Bottom: currentCell + height
Left: currentCell – 1
Right: currentCell + 1
Top Left Corner: currentCell – height – 1
Top Right Corner: currentCell – height + 1
Bottom Left Corner: currentCell + height – 1
Bottom Right Corner: currentCell + height + 1

Bounds checking, in the example case where currentCell – 1 would be considered off the left edge of the “grid”, we use % math and array bounds checking.

Game layer:

The Game class calls Grid to instantiate a new Grid.grid array populated with instances of the Cell class - Grid.grid[cell]. This is the internal state of the game. The Game class sets xPosition, yPosition, cellWidth, and cellHeight of every instance of Cell to provide a graphical representation of the internal state. This gives us the hierarchy: Game, Grid, and Cell.

The only logic bound to the Game layer is
- Where each Cell is placed
- The size of each Cell in terms of display size
- Whether a cursor falls within the boundaries of a cell and the type of click (left or right click)
- A timer
- The mapping of the internal state to the external (graphical) state

A valid game state is where a bomb has not been clicked, and there are tiles that are yet to be exposed. An end game state is where all tiles have been revealed and only cells that are mined have been sealed. Game.reset() can be called during a valid game state or end game state. Game.reset() resets the timer, and the timer starts when the first click event is detected. For example: MinedCell.expose() would result in an end game state, whereas NumberedCell.expose() allows continuation of a the valid game state.

The game's physical size on the screen is determined by the window.innerWidth and window.innerHeight of the browser's DOM to dynamically fit on any screen size. Each Cell size is a function of the game size and the number of cells in the game (default 10*10). Each Cell is drawn to the Canvas using CanvasRenderingContext2D.rect(xPos, yPos, width, height). The GUI will display the timer, as well as a reset button to call Game.reset().

Grid layer:

Grid(width, height, numberMines) is called by the Game layer. Grid.distributeMines(int mines) randomly places the mines in the Grid.grid array, and Grid.findAdjacentCells() creates instances of NumberedCell that are adjacent to the current MinedCell, and sets NumberedCell.value to indicate adjacent mines. Once all mines have been placed and NumberedCell.value calculated, the Grid array is returned to be used by the Game layer. The game layer interfaces with Cell instances' internal methods Cell.expose(), Cell.seal(), Cell.unseal() to change the internal state of the game.

Cell layer:

Cell is a base class with attributes: exposed (boolean), sealed(boolean), xPosition, yPosition, cellWidth, cellHeight, and texture.
Cell has three methods: expose(), seal(), and unseal().

MinedCell, EmptyCell, and NumberedCell inherit from Cell, and set appropriate textures to the texture attribute.
MinedCell() overrides the base class method expose() by calling Game.loseGame()
EmptyCell() overrides the base class method expose() by rendering an empty cell texture, and calling Grid.exposeNeighbors() to reveal empty cells, bordered by numbered cells.
NumberedCell() overrides the base class method expose() by rendering a cell with a number inside of it to indicate Cell.adjacentMines.

The Grid layer creates as many Cell instances (and child class instances) as necessary to fill the Grid.grid array.


2. Discuss what language you would use.

We were originally considering Java, but after doing research on some GUI and even game engine platforms, we decided on using JavaScript. Modern applications are mostly web oriented these days, and now that flash and java applets are being deprecated for the web, it would make sense to build something modern. We both have experience using JavaScript in both the front and back end, and pairing this with the simple yet powerful Html5 Canvas we believe would make a great application.

3. How do you plan to structure the program, what libraries would you use?

The Game class will import the Html5 Canvas and our Cell and Grid classes. The sole purpose of the Game class will be to configure the GUI, add event listeners to the cells, enable the visuals of the game state (things such as time, reset, clicked on a bomb, sealed a cell, or win), while Grid keeps track of every instance of Cell and their statuses.